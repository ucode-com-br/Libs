using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Net;
using System.Reflection;
using MongoDB.Driver.Core.Events;

namespace UCode.Mongo.OpenTelemetry
{
    /// <summary>
    /// Represents a subscriber that handles diagnostics activity events.
    /// Implements the IEventSubscriber interface to manage event subscription and handling.
    /// </summary>
    public class EventSubscriber : IEventSubscriber
    {
        /// <summary>
        /// Represents the options for instrumentation in the application.
        /// This field is read-only and encapsulates the configuration settings 
        /// related to how instrumentation should be handled.
        /// </summary>
        /// <remarks>
        /// The _options field is typically initialized through a constructor 
        /// and holds the parameters that dictate the behavior of the 
        /// instrumentation logic.
        /// </remarks>
        private readonly InstrumentationOptions _options;


        /// <summary>
        /// Represents the assembly name for the <see cref="EventSubscriber"/> type.
        /// This field is initialized with the name of the assembly to which the 
        /// <see cref="EventSubscriber"/> class belongs, using the <see cref="Assembly.GetName"/> method.
        /// </summary>
        /// <remarks>
        /// This field is marked as <c>
        internal static readonly AssemblyName AssemblyName = typeof(EventSubscriber).Assembly.GetName();


        /// <summary>
        /// Represents the name of the activity source. 
        /// This is a static readonly field that retrieves the name from the assembly.
        /// </summary>
        /// <remarks>
        /// The name is accessed with null-forgiving operator to ensure that it is not null.
        /// </remarks>
        internal static readonly string ActivitySourceName = AssemblyName.Name!;


        /// <summary>
        /// Represents a static and read-only instance of an <see cref="ActivitySource"/>.
        /// This instance is used to create and manage activity tracing for the application.
        /// </summary>
        /// <remarks>
        /// The <see cref="ActivitySourceName"/> is expected to be a string that identifies the source 
        /// of the telemetry data. It's typically the name of the application or component.
        /// The version of the <see cref="EventSubscriber"/> is retrieved using the 
        /// <see cref="SignalVersionHelper.GetVersion{T}"/> method, allowing for backward compatibility 
        /// and ensuring that the telemetry data is correctly versioned.
        /// </remarks>
        /// <seealso cref="ActivitySource"/>
        /// <seealso cref="SignalVersionHelper"/>
        internal static readonly ActivitySource ActivitySource = new(ActivitySourceName, SignalVersionHelper.GetVersion<EventSubscriber>());

        /// <summary>
        /// Represents the name of the activity related to MongoDB command events.
        /// This constant is used for identifying and logging specific command events 
        /// generated by the MongoDB driver.
        /// </summary>
        /// <remarks>
        /// This string is defined as a constant to ensure that the activity name
        /// remains consistent throughout the application and is easily referenced.
        /// </remarks>
        public const string ActivityName = "MongoDB.Driver.Core.Events.Command";

        /// <summary>
        /// Represents a readonly field that holds a reference to an instance of the 
        /// <see cref="ReflectionEventSubscriber"/> class. This field cannot be modified 
        /// after the initialization of the class in which it is declared.
        /// </summary>
        /// <remarks>
        /// The <see cref="ReflectionEventSubscriber"/> is typically used for subscribing 
        /// to events via reflection, thereby allowing dynamic event handling based on 
        /// the type of the event and its associated methods.
        /// </remarks>
        private readonly ReflectionEventSubscriber _subscriber;

        /// <summary>
        /// A thread-safe collection that maps an integer key to an Activity object.
        /// This dictionary allows for concurrent additions, removals, and lookups 
        /// of activities in a safe manner, making it suitable for multi-threaded scenarios.
        /// </summary>
        /// <remarks>
        /// The ConcurrentDictionary is initialized with the default constructor, 
        /// which allows the dictionary to grow dynamically as needed. 
        /// </remarks>
        private readonly ConcurrentDictionary<int, Activity> _activityMap = new();

        /// <summary>
        /// Initializes a new instance of the DiagnosticsActivityEventSubscriber class 
        /// with default instrumentation options where command text capture is disabled.
        /// </summary>
        /// <returns>
        /// A new instance of the DiagnosticsActivityEventSubscriber class.
        /// </returns>
        public EventSubscriber() : this(new InstrumentationOptions { CaptureCommandText = false })
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="EventSubscriber"/> class.
        /// </summary>
        /// <param name="options">The instrumentation options to be used by the subscriber.</param>
        public EventSubscriber(InstrumentationOptions options)
        {
            this._options = options;
            this._subscriber = new ReflectionEventSubscriber(this, bindingFlags: BindingFlags.Instance | BindingFlags.Public);
        }

        /// <summary>
        /// Tries to retrieve an event handler of the specified type.
        /// </summary>
        /// <typeparam name="TEvent">The type of the event for which the handler is being retrieved.</typeparam>
        /// <param name="handler">When this method returns, contains the event handler instance if found; otherwise, null.</param>
        /// <returns>
        /// True if the event handler was found; otherwise, false.
        /// </returns>
        public bool TryGetEventHandler<TEvent>(out Action<TEvent> handler)
            => this._subscriber.TryGetEventHandler(out handler);

        /// <summary>
        /// Handles the CommandStartedEvent by starting a new activity to trace the command execution.
        /// This includes capturing information about the database, collection, command name, 
        /// and network details, as well as adding relevant tags for monitoring purposes.
        /// </summary>
        /// <param name="event">The event containing data about the command that started.</param>
        /// <remarks>
        /// If the ShouldStartActivity option is not null and returns false for the provided event,
        /// the method will return early without starting the activity. The activity captures 
        /// various metrics related to the database operation via tags.
        /// </remarks>
        public void Handle(CommandStartedEvent @event)
        {
            if (this._options.ShouldStartActivity != null && !this._options.ShouldStartActivity(@event))
            {
                return;
            }

            var activity = ActivitySource.StartActivity(ActivityName, ActivityKind.Client);

            if (activity == null)
            {
                return;
            }

            var databaseName = @event.DatabaseNamespace?.DatabaseName;
            var collectionName = @event.GetCollectionName();

            // https://github.com/open-telemetry/semantic-conventions/blob/main/docs/database/database-spans.md
            activity.DisplayName = string.IsNullOrEmpty(collectionName) ? $"{@event.CommandName} {databaseName}" : $"{@event.CommandName} {collectionName}";

            activity.AddTag("db.system", "mongodb");
            activity.AddTag("db.application.name", this._options.ApplicationName);
            if (@event.ConnectionId?.ToString() != null)
            {
                activity.AddTag("db.connection.id", @event.ConnectionId?.ToString());
            }
            activity.AddTag("db.namespace", databaseName);
            activity.AddTag("db.collection.name", collectionName);
            activity.AddTag("db.operation.id", @event.OperationId);
            activity.AddTag("db.operation.name", @event.CommandName);
            activity.AddTag("network.transport", "tcp");


            var endPoint = @event.ConnectionId?.ServerId?.EndPoint;
            switch (endPoint)
            {
                case IPEndPoint ipEndPoint:
                    activity.AddTag("network.peer.address", ipEndPoint.Address.ToString());
                    activity.AddTag("network.peer.port", ipEndPoint.Port.ToString());
                    break;
                case DnsEndPoint dnsEndPoint:
                    activity.AddTag("server.address", dnsEndPoint.Host);
                    activity.AddTag("server.port", dnsEndPoint.Port.ToString());
                    break;
            }

            activity.AddTag("db.query.timestamp", @event.Timestamp);
            if (activity.IsAllDataRequested && this._options.CaptureCommandText)
            {
                activity.AddTag("db.query.text", @event.Command.ToString());
            }

            this._activityMap.TryAdd(@event.RequestId, activity);
        }

        /// <summary>
        /// Handles the event when a command successfully completes.
        /// This method looks up the activity associated with the given request ID and stops that activity.
        /// </summary>
        /// <param name="@event">The event that contains the data related to the command success, including the request ID.</param>
        public void Handle(CommandSucceededEvent @event)
        {
            if (this._activityMap.TryRemove(@event.RequestId, out var activity))
            {
                WithReplacedActivityCurrent(activity, activity.Stop);
            }
        }

        /// <summary>
        /// Handles the event when a command fails.
        /// It attempts to remove the associated activity from the activity map using the request ID
        /// and processes the failure details, adding relevant exception tags to the activity.
        /// </summary>
        /// <param name="@event">The event detailing the failed command.</param>
        public void Handle(CommandFailedEvent @event)
        {

            if (this._activityMap.TryRemove(@event.RequestId, out var activity))
            {
                WithReplacedActivityCurrent(activity, () =>
                {
                    var tags = this.ExceptionRecursive("", [], @event.Failure);

                    //if (!string.IsNullOrEmpty(@event.Failure.Message))
                    //{
                    //    tags.Add("exception.message", @event.Failure.Message);
                    //}

                    //if (@event.Failure.InnerException != null)
                    //{
                    //    tags.Add("exception.innerException.type", @event.Failure.InnerException.GetType().FullName);
                    //    tags.Add("exception.innerException.stacktrace", @event.Failure.InnerException.StackTrace);

                    //    if (!string.IsNullOrEmpty(@event.Failure.Message))
                    //    {
                    //        tags.Add("exception.message", @event.Failure.Message);
                    //    }
                    //}

                    activity.AddEvent(new ActivityEvent("exception", @event.Timestamp, tags));
                    activity.SetStatus(ActivityStatusCode.Error);
                    activity.Stop();
                });
            }
        }

        /// <summary>
        /// Recursively collects tags related to an exception and its inner exceptions, and stores them 
        /// in an `ActivityTagsCollection` using a specified prefix for each tag.
        /// </summary>
        /// <param name="prefix">
        /// A string used as a prefix for the tags pertaining to the current exception. 
        /// This prefix is updated to reflect the hierarchy of exceptions.
        /// </param>
        /// <param name="activityTagsCollection">
        /// An instance of `ActivityTagsCollection` where the exception tags will be added.
        /// </param>
        /// <param name="exception">
        /// The exception instance from which details will be extracted and added to the `ActivityTagsCollection`.
        /// </param>
        /// <returns>
        /// The updated `ActivityTagsCollection` that includes tags related to the provided exception 
        /// and all of its inner exceptions.
        /// </returns>
        private ActivityTagsCollection ExceptionRecursive(string prefix, ActivityTagsCollection activityTagsCollection, Exception exception)
        {
            var prefixed = $"{prefix}";


            if (string.IsNullOrWhiteSpace(prefix))
            {
                //exception
                prefixed += "exception";
            }
            else
            {
                prefixed += ".inner";
            }

            var tags = new ActivityTagsCollection
            {
                { $"{prefixed}.type", exception.GetType().FullName },
                { $"{prefixed}.stacktrace", exception.StackTrace },
            };

            if (!string.IsNullOrEmpty(exception.Message))
            {
                tags.Add($"{prefixed}.message", exception.Message);
            }

            if (!string.IsNullOrEmpty(exception.Source))
            {
                tags.Add($"{prefixed}.source", exception.Source);
            }

            if (exception.Data != null && exception.Data.Count > 0)
            {
                tags.Add($"{prefixed}.data", exception.Data);
            }

            if (exception.InnerException != null)
            {
                this.ExceptionRecursive($"{prefixed}", activityTagsCollection, exception.InnerException);
            }
            return activityTagsCollection;
        }

        /// <summary>
        /// Executes the specified action while temporarily replacing the currently active Activity
        /// with the provided Activity. If the provided Activity is the same as the current one,
        /// it executes the action immediately. It ensures that the current activity is restored
        /// to its previous state after execution, regardless of whether an exception is thrown.
        /// </summary>
        /// <param name="activity">The Activity to set as the current activity during the execution of the action.</param>
        /// <param name="action">The action to execute with the specified Activity as the current activity.</param>
        /// <exception cref="ArgumentNullException">Thrown when the provided action is null.</exception>
        private static void WithReplacedActivityCurrent(Activity activity, Action action)
        {
            var current = Activity.Current;
            if (activity == current)
            {
                action();
                return;
            }

            try
            {
                Activity.Current = activity;
                action();
            }
            finally
            {
                if (current?.IsStopped == true) // it's forbidden to assign stopped activity to Activity.Current
                {
                    Activity.Current = null;
                }
                else
                {
                    Activity.Current = current;
                }
            }
        }
    }
}
